// //Constants - need to use trial and error to fix them
// float Kp = 1;
// float Ki = 1;
// float Kd = 1;
// float c = 0.9;
// long previous_time = millis();

// void loop(){

//     sensors_event_t a, g, temp;
//     mpu.getEvent(&a, &g, &temp);

//     //approximation for now - probably smarter to change to more accurate angle reading
//     //using the same as base code - sin x = x and approximating the graviation
//     float tiltx = a.acceleration.x/9.67;
//     float tilty = a.acceleration.y/9.67;
//     float tiltz = a.acceleration.z/9.67;

//     //complementary filter

//     float tilt_angle = a.acceleration.x/9.67; //accelerometer
//     float differential = g.gyro.y; //gyroscope

//     unsigned long current_time = millis();
//     float dt = (current_time - previous_time)/1000;
//     previous_time = current_time;

//     float theta_n = (1-c)*tilt_angle + c*(differential*dt+theta_n);
    
//     //PID
//     float reference = 0;

//     float derivative = 
//     float integral = 

//     float error = reference - output;
//     float uoutput = Kp*error + Ki*integral + Kd+derivative;

//     step1.setTargetSpeedRad(uoutput);
//     step2.setTargetSpeedRad(-uoutput);

//     Serial.print(tilt_angle);
//     Serial.print(' ');
//     Serial.print(theta_n);
//     Serial.print(' ');
//     Serial.print(uoutput);
// }



        // else if (tilt_angle_z < -0.05) {
        //   unsigned long current_time = millis();
        //   float dt = (current_time - previous_time)/1000;
        //   previous_time = current_time;
        //   theta_n = (1-c)*tilt_angle_z + c*(gyro_y*dt+theta_n);    
        //   //PID
        //   float reference = 0.046;               // reference == setpoint (for theory)
        //   error = reference - theta_n;    
        //   float derivative = -gyro_y;
        //   integral += error*dt;
        //   uoutput = Kp*error + Ki*integral + Kd*derivative;
        // }
        // else if (tilt_angle_z > 0.1) {
        //   unsigned long current_time = millis();
        //   float dt = (current_time - previous_time)/1000;
        //   previous_time = current_time;
        //   theta_n = (1-c)*tilt_angle_z + c*(gyro_y*dt+theta_n);    
        //   //PID
        //   float reference = 0.006;               // reference == setpoint (for theory)
        //   error = reference - theta_n;    
        //   float derivative = -gyro_y;
        //   integral += error*dt;
        //   uoutput = Kp*error + Ki*integral + Kd*derivative;
        // }


    printTimer += PRINT_INTERVAL;
    Serial.print(accelAngle, 4); Serial.print(",");
    Serial.print(gyroAngle, 4); Serial.print(",");
    Serial.print(spinAngle, 4); Serial.print(",");
    Serial.print(current_speed, 4); Serial.print(",");
    Serial.print(spinComp,4); Serial.print(",");
    Serial.print(prev_theta_n,4); Serial.print(",");
    Serial.print(prev_theta_n - Turndrive, 4); Serial.print(",");
    Serial.print(WheelPos, 4); Serial.print(",");
    Serial.print(error, 4); Serial.print(",");
    Serial.print(turn_error, 4); Serial.print(",");
    if(currentOperation == 's'){
      Serial.print(", 1, 0, 0, 0, 0"); 
    }
    else if(currentOperation == 'f'){
      Serial.print(", 0, 1, 0, 0, 0"); 
    }
    else if(currentOperation == 'r'){
      Serial.print(", 0, 0, 1, 0, 0"); 
    }
    else if(currentOperation == 'c'){
      Serial.print(", 0, 0, 0, 1, 0"); 
    }
    else if(currentOperation == 'a'){
      Serial.print(", 0, 0, 0, 0, 1"); 
    }
    Serial.println();







